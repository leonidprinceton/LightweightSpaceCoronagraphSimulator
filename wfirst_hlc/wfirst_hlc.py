##
# This is a simulator of WFIRST's Hybrid Lyot Coronagraph based on FALCO (https://github.com/ajeldorado/falco-matlab, from March 2020).
# It simulates *small* deviations from a perfect dark hole due to wavefront errors and deformable mirror (DM) actuations.
# It can also simulate the average contribution of fast jitter in low order wavefront modes.
# These linear approximationa are based on pupil-plane zernike sensitivitiy matrices and DM Jacobians generated by FALCO for 6 wavelenghts.
##

import numpy as np
import os

# prepare for loading FALCO-generated files from the directory of this module
_wfirst_hlc_data_dir = os.path.dirname(os.path.abspath(__file__))
_load_data = lambda fname: np.load(os.path.join(_wfirst_hlc_data_dir, fname))

availible_wavelengths = [546,558,569,581,592,604] #in nanometers
n_channels = len(availible_wavelengths)
# Jacobians from two DMs in all wavelengths: a complex (n_pixels, n_channels, n_actuators) array of E-field/voltage [sqrt(contrast units)/V)]; only dark hole pixels
jacobian = np.stack([np.block([_load_data("jacobian_DM1_%dnm.npy"%(l)), _load_data("jacobian_DM2_%dnm.npy"%(l))]) for l in availible_wavelengths], axis=1)
n_actuators = jacobian.shape[2]
n_pixels = jacobian.shape[0] #dark hole pixels

DH_mask = np.load(os.path.join(_wfirst_hlc_data_dir, "DH_mask.npy"))
DH_indices = np.where(DH_mask) #indices of dark hole pixels in the 2D mask
# load the electric field (E-field) in the dark hole after it has been created by FALCO and select just he dark hole pixels
perfect_E = np.load(os.path.join(_wfirst_hlc_data_dir, "perfect_DH_E_fields.npy"))[DH_indices]

# load the E-field sensitivity to zernike perturpation in pupil-plane and select just he dark hole pixels: a complex (n_pixels, n_channels, n_zernikes) array of E-field/coefficient [sqrt(contrast units)/m)]
zernikes_sensitivity = np.load(os.path.join(_wfirst_hlc_data_dir, "zernike_to_E_field_by_OSA_indices.npy"))[DH_indices]
n_zernikes = zernikes_sensitivity.shape[2]
zernikes_order = np.round(np.sqrt(2*np.arange(1,n_zernikes+1))).astype(int)-1 #OSA ordering of zernike coefficients [0,1,1,2,2,2,3,3,3,3,...]

# Zernikes which are monitroed and control by the Low-Order Wacefront Sensing (LOWFS)
LOWFS_zernikes_mask = np.array([1,1,1,1,1,1,1,1,1,1,0,0,1] + [0]*(n_zernikes - 13))

# compute jitter in at most 15 zernikes (to save time and space)
n_jitter_zernikes = 15
jitter_E_sensitivity = zernikes_sensitivity[:,:,:n_jitter_zernikes]
# jitter results in an incoherent contribuion to image intensity which depends on the joint probability distribution of the jitter zernikes
jitter_I_sensitivity =  np.einsum("...i,...j", jitter_E_sensitivity, np.conj(jitter_E_sensitivity))

def get_E_field(DM_voltages=None, drift_zernikes=None, drift_DM_voltages=None):
    """
    Approximates the electric field in the dark hole in the presence of *small* DM actuations, pupil-plane wavefront and DM actuators drift

    DM_voltages (optional)       - deterministic DM voltages (e.g. closed loop control)
    drift_zernikes (optional)    - non-deterministic zernike coefficients of pupil-plane wavefront phase abberation (in meters)
    drift_DM_voltages (optional) - non-deterministic DM voltages (e.g. DM actuators drift)

    returns complex electric field at dark hole pixels for all simualted wavelentghs
    """
    E = np.copy(perfect_E)

    if not DM_voltages is None:
        E += np.matmul(jacobian, DM_voltages)

    if not drift_zernikes is None:
        E += np.matmul(zernikes_sensitivity, drift_zernikes)

    if not drift_DM_voltages is None:
        E += np.matmul(jacobian, drift_DM_voltages)

    return E

def get_intensity(broadband, DM_voltages=None, drift_zernikes=None, drift_DM_voltages=None, jitter_zernikes_cov=None, return_E_field=False):
    """
    Approximates the intensity in the dark hole in the presence of *small* DM actuations, pupil-plane wavefront and DM actuators drift, and jitter in low-order Zernikes in pupil plane

    broadband                      - if True, the intensities across all wavelenghts (channels) are summed
    DM_voltages (optional)         - deterministic DM voltages (e.g. closed loop control)
    drift_zernikes (optional)      - non-deterministic zernike coefficients of pupil-plane wavefront phase abberation (in meters)
    drift_DM_voltages (optional)   - non-deterministic DM voltages (e.g. DM actuators drift)
    jitter_zernikes_cov (optional) - covariance of the distribution of the fast varying Zernike coefficients of the wavefront error (up to n_jitter_zernikes); either 1D array of non-negative n_jitter_zernikes coefficients or 2D semi-positive definite matrix of dimension n_jitter_zernikes
    return_E_field (defaule False) - also return the electrif fields

    returns the (possibly) incoherent sum of intensities from all sources
    """
    E = get_E_field(DM_voltages, drift_zernikes, drift_DM_voltages)
    I = np.abs(E)**2

    if not jitter_zernikes_cov is None:
        jitter_zernikes_cov = np.array(jitter_zernikes_cov)
        if jitter_zernikes_cov.ndim == 1:
            jitter_zernikes_cov = np.diag(jitter_zernikes_cov)

        # incoherently average the cross-interaction of all jitter modes (separately for each channel)
        assert(jitter_zernikes_cov.shape == (n_jitter_zernikes,n_jitter_zernikes))
        I += np.abs(np.einsum("...ij,ij", jitter_I_sensitivity, jitter_zernikes_cov))

    if broadband:
        I = np.sum(I, axis=1)

    if return_E_field:
        return I,E
    else:
        return I

def measurement_from_intensity(I, intensity_to_photons, dark_current, seed=None):
    """
    The simplest pseudo-random detector model in photon counting mode

    I                    - intensity in contrast units
    intensity_to_photons - translates from contrast units to average photons per exposure per pixel
    dark_current         - average photons contribution per exposure per pixel from dark current
    seed (optional)      - random seed

    returns photons counts (same shape as I)
    """
    if not seed is None:
        np.random.seed(seed)
    return np.random.poisson(I*intensity_to_photons + dark_current)

def DH_to_image(arr):
    """
    Maps dark hole pixels to their positions in the image

    arr - array of dark hole pixel values (size of first dimension must be n_pixels)

    returns an array with one extra dimension and each pixels mapped to its corresponing position in the 2D image
    """
    image = np.zeros(DH_mask.shape + arr.shape[1:], dtype=arr.dtype)
    image[DH_indices] = arr
    return image
    
